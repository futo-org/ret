addExample("Hello World", "rv64", "// RISC-V doesn't work in the web-based emulator yet.\n");
addExample("Registers", "rv64", "// The following instructions are equivalent\naddi x0, x0, 0x1\nli x0, 0x1\n// x1 = x0 + x0\nadd x1, x0, x0\n");
addExample("Registers 2", "rv64", "");
addExample("Registers", "arm32", "// Arm32 has 11 general-purpose registers (r0-r10)\n\n// Add two numbers\nmov r0, #0x50\nmov r1, #0xb0\nadd r2, r0, r1 // r2 = r0 + r1\n\n// And a few other registers worth noting:\n// fp (frame pointer)\n// sp (stack pointer)\n// lr (link register)\n");
addExample("Jumps", "arm32", "// 'b' is short for 'branch'. This tells the CPU to move execution somewhere else.\nb skip\nmov r0, #0x123 // this never gets called\n// labels are defined with a name and a colon. Labels aren't encoded as instructions, they\n// are saved by the assembler as offsets in the code.\nskip:\n");
addExample("Conditions", "arm32", "mov r0, #0x10\nmov r1, #0x20\n// This copies r0 and r1 into some internal registers. These internal registers are used\n// by conditional branch instructions.\ncmp r0, r1\n// Jump to end if r0 < r1\n// blt is a conditional branch instructions. There are others, like bgt (branch greater than), beq, etc\nblt end\nmov r0, #0x123 // Since 0x10 < 0x20, this instruction doesn't get run.\nend:\n");
addExample("Functions", "arm32", "mov r0, #0x5\nmov r1, #0x5\n// bl is short for 'branch link'. It saves the current position in lr (the link register)\n// and jumps to a label.\nbl multiply\n\nb skip\nmultiply:\n	mul r0, r0, r1\n	bx lr\nskip:\n");
addExample("Stack", "arm32", "// Note: the emulator already has the stack pointer setup.\nmov r0, #0x123\npush {r0} // Pushes 0x123 onto the stack. the stack pointer (sp) gets decremented by 4.\nmov r0, #0x0\npop {r0} // Pops the 0x123 back into r0, and sp gets incremented by 4.\n\n// This can also be written as:\nstmdb sp!, {r0} // stmdb stands for Store Multiple, Decrement Before\nmov r0, #0x0\nldmia sp!, {r0} // ldmia stands for Load multiple, increment after\n");
addExample("Hello World", "arm32", "adr r1, string\nldr r2, UART_DR\ntop:\n	ldrb r0, [r1]\n	cmp r0, #0x0\n	beq end\n	str r0, [r2]\n	add r1, r1, #0x1\n	b top\nend:\n\nb skip\nUART_DR: .int 0x9000000\nstring:\n.ascii \"Hello, World\\\\n\"\n.byte 0\n.align 4\nskip:\n");
addExample("Hello World", "arm64", "ldr w2, UART_DR\nadr x1, string\ntop:\n	ldrb w0, [x1]\n	cmp w0, #0x0\n	beq end\n	str w0, [x2]\n	add x1, x1, #0x1\n	b top\nend:\n\nb skip\nUART_DR: .int 0x9000000\nstring:\n.ascii \"Hello, World\\n\"\n.byte 0\n.align 4\nskip:\n");
addExample("Hello World (PIC)", "arm64", "// Hello world that doesn't use adr\nldr w2, UART_DR\nldr w1, string_addr\ntop:\n	ldrb w0, [x1]\n	cmp w0, #0x0\n	beq end\n	str w0, [x2]\n	add x1, x1, #0x1\n	b top\nend:\n\nb skip\nUART_DR: .int 0x9000000\nstring_addr: .int string\nstring:\n.ascii \"Hello, World\\n\"\n.byte 0\n.align 4\nskip:\n");
addExample("Hello World", "x86gnu", "mov eax, 0x9000000 // UART_DR\nmov dword ptr [eax], 'X'\nmov dword ptr [eax], '\\n'\n");
addExample("Hello World", "x86nasm", "mov eax, 0x9000000 ; UART_DR\nmov dword [eax], 'H'\nmov dword [eax], 'e'\nmov dword [eax], 'l'\nmov dword [eax], 'l'\nmov dword [eax], 'o'\nmov dword [eax], '\\n'\n");
addExample("Hello World", "x86intel", "mov eax, 0x9000000 // UART_DR\nmov dword ptr [eax], 'X'\nmov dword ptr [eax], '\\n'\n");
