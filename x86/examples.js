addExample("Hello World", "rv", "// Note: RISC-V doesn't work in the web-based emulator yet.\n// RISC-V Resources: \"https://msyksphinz-self.github.io/riscv-isadoc\" \n\nli x0, 0x9000000\nli x1, 'X'\nsw x1, 0(x0) // Store word x1 into address at x0 at offset 0\nli x1, '\\n'\nsw x1, 0(x0)\n");
addExample("Registers", "rv", "// LI stands for load immediate.\n// This is equivalent to mov in other architectures.\nli x0, 0x1\n\n// The add instruction can add two registers\nadd x1, x0, x0 // x1 = x0 + x0\n\n// addi adds a register to an immediate value (which is a number rather than register)\naddi x1, x0, #0x5 // x1 = x0 + x5\n");
addExample("Registers", "arm32", "// Arm32 has 11 general-purpose registers (r0-r10)\n\n// Add two numbers\nmov r0, #0x50\nmov r1, #0xb0\nadd r2, r0, r1 // r2 = r0 + r1\n\n// And a few other registers worth noting:\n// fp (frame pointer)\n// sp (stack pointer)\n// lr (link register)\n");
addExample("Jumps", "arm32", "// 'b' is short for 'branch'. This tells the CPU to move execution somewhere else.\nb skip\nmov r0, #0x123 // this never gets called\n// labels are defined with a name and a colon. Labels aren't encoded as instructions, they\n// are saved by the assembler as offsets in the code.\nskip:\n");
addExample("Conditions", "arm32", "mov r0, #0x10\nmov r1, #0x20\n// This copies r0 and r1 into some internal registers. These internal registers are used\n// by conditional branch instructions.\ncmp r0, r1\n// Jump to end if r0 < r1\n// blt is a conditional branch instructions. There are others, like bgt (branch greater than), beq, etc\nblt end\nmov r0, #0x123 // Since 0x10 < 0x20, this instruction doesn't get run.\nend:\n");
addExample("Functions", "arm32", "mov r0, #0x5\nmov r1, #0x5\n// bl is short for 'branch link'. It saves the current position in lr (the link register)\n// and jumps to a label.\nbl multiply\n\nb skip\nmultiply:\n	mul r0, r0, r1\n	bx lr\nskip:\n");
addExample("Stack", "arm32", "// Note: the emulator already has the stack pointer setup.\nmov r0, #0x123\npush {r0} // Pushes 0x123 onto the stack. the stack pointer (sp) gets decremented by 4.\nmov r0, #0x0\npop {r0} // Pops the 0x123 back into r0, and sp gets incremented by 4.\n\n// This can also be written as:\nstmdb sp!, {r0} // stmdb stands for Store Multiple, Decrement Before\nmov r0, #0x0\nldmia sp!, {r0} // ldmia stands for Load multiple, increment after\n");
addExample("Hello World", "arm32", "adr r1, string\nldr r2, UART_DR\ntop:\n	ldrb r0, [r1]\n	cmp r0, #0x0\n	beq end\n	str r0, [r2]\n	add r1, r1, #0x1\n	b top\nend:\n\nb skip\nUART_DR: .int 0x9000000\nstring:\n.ascii \"Hello, World\\n\"\n.byte 0\n.align 4\nskip:\n");
addExample("Hello World", "arm64", "adr x1, string\nldr w2, UART_DR\ntop:\n	ldrb w0, [x1]\n	cmp w0, #0x0\n	beq end\n	str w0, [x2]\n	add x1, x1, #0x1\n	b top\nend:\n\nb skip\nUART_DR: .int 0x9000000\nstring:\n.ascii \"Hello, World\\n\"\n.byte 0\n.align 4\nskip:\n");
addExample("Registers", "arm64", "// x0-x28: General-purpose registers\n// x29/fp: Frame pointer\n// x30/lr: Link register\n// All 'x' registers are 64 bit.\nmov x0, #0xffffffffffffffff\n// The lower (least significant) 32 bits of each 64 bit register can be\n// accessed through a 'w' register:\nmov w0, #0x123\n\n// Note that fp and lr are just aliases. The following are identical:\nmov lr, #0x0\nmov x30, #0x0\nmov fp, #0x0\nmov x29, #0x0\n");
addExample("Exception Levels", "arm64", "// Get current exception level\nmrs x0, CurrentEL\nlsr x0, x0, #0x2\n// We are in EL1!\n");
addExample("SIMD", "arm64", "// Arm64 has 32 128bit floating point/simd registers.\n\nadr x0, dat\n\n// Each register has a:\nldr q0, [x0] // 128bit variant\nldr d0, [x0] // 64bit variant\nldr s0, [x0] // 32bit variant\nldr h0, [x0] // 16bit variant\nldr b0, [x0] // 8bit variant\n\n// You can't use mov on these registers. You can use fmov, but only for 32bit/64bit.\nfmov d0, x0\nfmov s0, w0\n\nb skip\ndat:\n.int 0x0\n.int 0x0\n.int 0x0\n.int 0x0\nskip:\n");
addExample("Hello World", "x86gnu", "mov eax, 0x9000000 // UART_DR\nmov dword ptr [eax], 'H'\nmov dword ptr [eax], 'e'\nmov dword ptr [eax], 'l'\nmov dword ptr [eax], 'l'\nmov dword ptr [eax], 'o'\nmov dword ptr [eax], '\\n'\n");
addExample("Hello World", "x86nasm", "mov eax, 0x9000000 ; UART_DR\nmov dword [eax], 'H'\nmov dword [eax], 'e'\nmov dword [eax], 'l'\nmov dword [eax], 'l'\nmov dword [eax], 'o'\nmov dword [eax], '\\n'\n");
addExample("Hello World", "x86intel", "mov eax, 0x9000000 // UART_DR\nmov dword ptr [eax], 'H'\nmov dword ptr [eax], 'e'\nmov dword ptr [eax], 'l'\nmov dword ptr [eax], 'l'\nmov dword ptr [eax], 'o'\nmov dword ptr [eax], '\\n'\n");
