// autogenerated by tool.py
var examples = [];
function addExample(name, arch, data) {
	examples.push({
		name: name,
		arch: arch,
		data: data
	});
}
addExample("Hello World", "rv", "la a0, string\nli a2, 0x9000000 // UART_DR, write here to print characters\n\ntop:\nlbu a1, 0(a0)\nsw a1, 0(a2)\naddi a0, a0, 1\nbne a1, zero, top\n\nj skip\nstring: .string \"Hello World\"\n.align 1\nskip:\n");
addExample("Registers", "rv", "// LI stands for load immediate.\n// This is equivalent to mov in other architectures.\nli a1, 0x1\n\n// x0 is a zero register. Writes to it will be ignored.\nli x0, 0x2\n\n// Read more about the RISC-V ABI: https://en.wikichip.org/wiki/risc-v/registers\n\n// The add instruction can add two registers\nadd a2, a1, a1 // x1 = x0 + x0\n\n// addi adds a register to an immediate value (which is a number rather than register)\naddi a2, a1, 0x5 // x1 = x0 + x5\n");
addExample("Functions", "rv", "j skip\nnested:\n	jr ra\n\nmyfunc:\n	addi sp, sp, -8\n	sd ra, 0(sp) // ra = return address\n	call nested\n	li a0, 0x123\n	ld ra, 0(sp)\n	addi sp, sp, 8\n	jr ra\nskip:\n\ncall myfunc\n");
addExample("Hello World", "arm32", "// https://armasm.com/ is an excellent resource for learning ARM Assembly\nadr r1, string\nldr r2, UART_DR\ntop:\n	ldrb r0, [r1]\n	cmp r0, #0x0\n	beq end\n	str r0, [r2]\n	add r1, r1, #0x1\n	b top\nend:\n\nb skip\nUART_DR: .int 0x9000000 // UART_DR, write here to print characters\nstring:\n.ascii \"Hello, World\\n\"\n.byte 0\n.align 2 \nskip:\n");
addExample("Registers", "arm32", "// Arm32 has 11 general-purpose registers (r0-r10)\n\n// Add two numbers\nmov r0, #0x50\nmov r1, #0xb0\nadd r2, r0, r1 // r2 = r0 + r1\n\n// And a few other registers worth noting:\n// fp (frame pointer)\n// sp (stack pointer)\n// lr (link register)\n");
addExample("Jumps", "arm32", "// 'b' is short for 'branch'. This tells the CPU to move execution somewhere else.\nb skip\nmov r0, #0x123 // this never gets called\n// labels are defined with a name and a colon. Labels aren't encoded as instructions, they\n// are saved by the assembler as offsets in the code.\nskip:\n");
addExample("Conditions", "arm32", "mov r0, #0x10\nmov r1, #0x20\n// This copies r0 and r1 into some internal registers. These internal registers are used\n// by conditional branch instructions.\ncmp r0, r1\n// Jump to end if r0 < r1\n// blt is a conditional branch instructions. There are others, like bgt (branch greater than), beq, etc\nblt end\nmov r0, #0x123 // Since 0x10 < 0x20, this instruction doesn't get run.\nend:\n");
addExample("Functions", "arm32", "mov r0, #0x5\nmov r1, #0x5\n// bl is short for 'branch link'. It saves the current position in lr (the link register)\n// and jumps to a label.\nbl multiply\n\nb skip\nmultiply:\n	mul r0, r0, r1\n	bx lr\nskip:\n");
addExample("Stack", "arm32", "// Note: the emulator already has the stack pointer setup.\nmov r0, #0x123\npush {r0} // Pushes 0x123 onto the stack. the stack pointer (sp) gets decremented by 4.\nmov r0, #0x0\npop {r0} // Pops the 0x123 back into r0, and sp gets incremented by 4.\n\n// This can also be written as:\nstmdb sp!, {r0} // stmdb stands for Store Multiple, Decrement Before\nmov r0, #0x0\nldmia sp!, {r0} // ldmia stands for Load multiple, increment after\n");
addExample("Hello World", "arm64", "// https://mariokartwii.com/armv8/ is an excellent resource for learning ARM64 Assembly\nadr x1, string\nldr w2, UART_DR\ntop:\n	ldrb w0, [x1]\n	cmp w0, #0x0\n	beq end\n	str w0, [x2]\n	add x1, x1, #0x1\n	b top\nend:\n\nb skip\nUART_DR: .int 0x9000000 // UART_DR, write here to print characters\nstring:\n.ascii \"Hello, World\\n\"\n.byte 0\n.align 2 // align to a power of 2\nskip:\n");
addExample("Registers", "arm64", "// x0-x28: General-purpose registers\n// x29/fp: Frame pointer\n// x30/lr: Link register\n// All 'x' registers are 64 bit.\nmov x0, #0xffffffffffffffff\n// The lower (least significant) 32 bits of each 64 bit register can be\n// accessed through a 'w' register:\nmov w0, #0x123\n\n// Note that fp and lr are just aliases. The following are identical:\nmov lr, #0x0\nmov x30, #0x0\nmov fp, #0x0\nmov x29, #0x0\n");
addExample("Stack", "arm64", "mov x0, #0x123\n\n// The ! flag at the end of this instruction will update the register we are writing to.\n// In this case x0 is written to sp - 8, and 8 is subtracted from sp.\nstr x0, [sp, #-0x8]!\n// So that is equivalent to:\nstr x0, [sp, #-0x8]\nsub sp, sp, 0x8\n\nmov x0, #0x0\n\n// This loads the value back into x0, and increments sp by 8\nldr x0, [sp], 0x8\n\n// Store and Load multiple\nstp x0, x1, [sp, #-0x10]!\nldp x0, x1, [sp], #0x10\n");
addExample("Functions", "arm64", "b skip\nmy_second_func:\n	ret\nmy_func:\n	// lr (link register) must be preserved between function calls\n	// so the CPU knows where to return to after a nested call\n	str lr, [sp, #-0x8]!\n	bl my_second_func\n	ldr lr, [sp], 0x8\n	ret\nskip:\n\nbl my_func\n");
addExample("Exception Levels", "arm64", "// Get current exception level\n// https://developer.arm.com/documentation/ddi0601/latest/AArch64-Registers/CurrentEL--Current-Exception-Level\n\nmrs x0, CurrentEL\nlsr x0, x0, #0x2\n// We are in EL1!\n");
addExample("SIMD", "arm64", "// Arm64 has 32 128bit floating point/simd registers.\n\nadr x0, dat\n\n// Each register has a:\nldr q0, [x0] // 128bit variant\nldr d0, [x0] // 64bit variant\nldr s0, [x0] // 32bit variant\nldr h0, [x0] // 16bit variant\nldr b0, [x0] // 8bit variant\n\n// You can't use mov on these registers. You can use fmov, but only for 32bit/64bit.\nfmov d0, x0\nfmov s0, w0\n\nb skip\ndat:\n.int 0x0\n.int 0x0\n.int 0x0\n.int 0x0\nskip:\n");
addExample("Mandelbrot", "arm64", "// This is adapted from the Rosetta Code example:\n// https://rosettacode.org/wiki/Mandelbrot_set#AArch64_Assembly\n\n// .req can be used to create an alias for an identifier.\n// In this case, we create a bunch of register aliases.\nxsize   .req x9\nxsize_w .req w9\nysize   .req x10\nysize_w .req w10\n\nmin_imag .req s8\nmax_imag .req s9\nmin_real .req s10\nmax_real .req s9\n\nimag .req s11\nreal .req s12\n\nstep_x .req s13\nstep_y .req s14\n\nzi .req s15\nzr .req s16\n\na .req s17\nb .req s18\n\nftemp_1 .req s19\nftemp_2 .req s20\n\ny .req x19\ny_w .req w19\nx .req x20\nx_w .req w20\nn .req x21\nlimit .req x22\n\nitemp_1 .req x23\nitemp_1w .req w23\n\nmain:\n	mov xsize, #108/2\n	mov ysize, #72/2\n	mov limit, #32\n	fmov min_imag, #-1.0\n	fmov max_imag, #1.0\n	fmov min_real, #-2.0\n//	fmov max_real  #1.0\n\n	fsub  step_x,   max_real, min_real\n	scvtf ftemp_1,  xsize_w\n	fdiv  step_x,   step_x, ftemp_1\n	fsub  step_y,   max_imag, min_imag\n	scvtf ftemp_1,  ysize_w\n	fdiv  step_y,   step_y, ftemp_1\n\n	mov y, #0\nloop_y:\n	cmp y, ysize\n	b.eq end_loop\n\n	scvtf ftemp_1, y_w\n	fmadd imag, step_y, ftemp_1, min_imag\n\n	mov x, #0\nloop_x:\n	cmp x, xsize\n	b.eq end_line\n\n	scvtf ftemp_1, x_w\n	fmadd real, step_y, ftemp_1, min_real\n\n	fmov zr, real\n	fmov zi, imag\n\n	mov n, #0\nloop_iter:\n	cmp n, limit\n	b.eq draw_point\n\n	fmul a, zr, zr\n	fmul b, zi, zi\n	fadd ftemp_1, a, b\n\n	fmov ftemp_2, #4.0\n	fcmp ftemp_1, ftemp_2\n	b.gt draw_point\n\n	fmul  zi, zi, zr\n	fmov  ftemp_2, #2.0\n	fmadd zi, zi, ftemp_2, imag\n	fsub  zr, a, b\n	fadd  zr, zr, real\n\n	add n, n, #1\n	b loop_iter\n\ndraw_point:\n	add x, x, #1\n	mov x1, 0x9000000\n	mov x0, #64\n	sub x0, x0, n\n	str w0, [x1]\n	b loop_x\n\nend_line:\n	add y, y, #1\n	mov x1, 0x9000000\n	mov w0, '\\n'\n	str w0, [x1]\n	b loop_y\n\nend_loop:\n");
addExample("Hello World", "ppc64", "// todo\n");
addExample("Hello World", "ppc32", "# PowerPC support is not fully finished yet\n# Unicorn doesn't support ppc64, so this is in 32 bit mode by default.\nlis r3, 0x900 # UART_DR 0x9000000\naddi r2, r0, 'X'\nstw r2, 0x0 (r3)\naddi r2, r0, '\\n'\nstw r2, 0x0 (r3)\n");
addExample("Hello World (GNU)", "x86gnu", "// NOTE: AT&T/GAS support in keystone is incomplete\nmovl $0x9000000, %eax // UART_DR, write here to print characters\nmovl $'H', (%eax)\nmovl $'e', (%eax)\nmovl $'l', (%eax)\nmovl $'l', (%eax)\nmovl $'o', (%eax)\nmovl $'\\n', (%eax)\n");
addExample("Hello World (AT&T)", "x86att", "// NOTE: AT&T/GAS support in keystone is incomplete\nmovl $0x9000000, %eax // UART_DR, write here to print characters\nmovl $'H', (%eax)\nmovl $'e', (%eax)\nmovl $'l', (%eax)\nmovl $'l', (%eax)\nmovl $'o', (%eax)\nmovl $'\\n', (%eax)\n");
addExample("Hello World (NASM)", "x86nasm", "; NOTE: NASM support in keystone is incomplete \nmov ebx, 0x9000000 ; UART_DR, write here to print characters\n\nmov esi, string\ntop:\n	lodsb ; Load byte from [esi] into al, increment esi by 1\n	test al, al\n	jz end ; jump if zero\n	mov [ebx], al ; Store al into UART_DR\n	jmp top\nend:\n\njmp skip\nstring: db \"Hello, World\\n\\0\"\nskip:\n");
addExample("Hello World", "x86intel", "mov ebx, 0x9000000 ; UART_DR, write here to print characters\n\nmov esi, string\ntop:\n	lodsb ; Load byte from [esi] into al, increment esi by 1\n	test al, al\n	jz end ; jump if zero\n	mov [ebx], al ; Store al into UART_DR\n	jmp top\nend:\n\njmp skip\nstring: .string \"Hello, World\\n\"\nskip:\n");
addExample("Registers", "x86intel", "; More info on x86: https://en.wikibooks.org/wiki/X86_Assembly/X86_Architecture\n\nmov rax, 0x12345678\nmov eax, 0x12345678\nmov ax, 0x8888\nmov al, 0xff\n");
addExample("Functions", "x86intel", "jmp skip\nmy_func2:\n	ret\n\nmy_func:\n	call my_func2\n	ret\nskip:\n\ncall my_func\n");
addExample("Sierpinski", "x86intel", "; Adapted from https://rosettacode.org/wiki/Sierpinski_triangle#X86_Assembly\nmov ebp, 0x9000000 ; uart_dr\nstart: xor     ebx, ebx        ; S1:= 0\n	mov     edx, 0x8000      ; S2:= $8000\n	mov     cx, 16          ; for I:= Size downto 1\ntri10: mov     ebx, edx        ; S1:= S2\ntri15: test    edx, edx        ; while S2#0\n	je      tri20\n	mov    al, '*'         ; ChOut\n	test   dl, 0x01         ;  if S2&1 then '*' else ' '\n	jne    tri18\n	mov   al, ' '\ntri18: mov [ebp], eax ; write to uart_dr\n	shr    edx, 1          ; S2>>1\n	jmp    tri15\ntri20: mov     al, 0x0D         ; carriage return\n	mov [ebp], eax ; write to uart_dr\n	mov     al, '\\n'\n	mov [ebp], eax ; write to uart_dr\n	shl     ebx, 1          ; S2:= S2 xor S1<<1\n	xor     edx, ebx\n	shr     ebx, 2          ; S2:= S2 xor S1>>1\n	xor     edx, ebx\n	dec    ecx ; dec/cmp/jne can also be `loop tri10`\n	cmp ecx, 6\n	jne tri10 ; next I\n");
